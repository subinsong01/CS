# Recap a computer architectue 

## 1. 컴퓨터의 계층 구조 :  응용 프로그램 <-> 운영 체제 <-> HW

    📍 컴퓨터 HW 구성 : CPU / 메모리
   
        - CPU : 명령어를 해석하여 실행하는 장치 (무조건 메모리랑만 통신)
           ⭐️CPU가 프로그램을 실행시키려면 '메인 메모리'에 적재 되어 있어야 하므로 (CPU입장에서) 굉장히 중요
   
        - 메모리 : 명령어들 저장 + 필요한 데이터들 저장 (주소를 통해 이리저리 구분)
        - 컴퓨터에 연결되는 모든 장치들은 최종적으로 메인보드와 연결 

     📍BUS : 메인보드에 연결된 각 장치들은 메인보드 내 '버스'를 통해 통신한다

         - CPU 내부버스 / 시스템 버스(핵심) / I.O 버스
         - 데이터 버스 / 주소 버스 / 제어 버스

      📍 폰 노이만 구조 : 디스크 -> (버스) -> 메모리 -> (버스) -> CPU 
   
   <img width="256" alt="스크린샷 2024-04-05 오후 11 40 40" src="https://github.com/subinsong01/TIL/assets/134045937/8209e285-6cbd-4c4c-b78c-c8d4bc1e087d">

## 2. 병목현상 (버스의 크기 == CPU가 한번에 처리할 수 있는 데이터의 크기(word))

   > 해결 방안 

     📍 물리적 설계
   
       - 메모리의 클럭을 증가시키고, 클럭 낭비를 줄이기
         > DDR = Double Data Rate
         > Positive edge / Negative edge = 모두 데이터 처리에 할당
   
       - 듀얼 채널
         > 메모리 꽂는 슬롯에 칸 별로 색이 칠해진 이유
         > 병렬화를 통해 한번에 더 많은 데이터 접근
   
       - CPU랑 가까운 위치
         > 가까이 둬서 데이터 이동시간을 아끼자 !

    📍 구조적 설계

       - 버퍼 도입 (Buffer = 데이터 전달 간 임시 저장하는 장치/장소를 의미)
       - 속도 차이를 완화하는 역할을 의미
         > 일정량의 데이터를 모아 옮김으로써 속도 차이 완화
       - 스풀 : 버퍼의 SW 구현 형태 = 프린터

## 3. 메모리 계층 구조

   📍 캐시 : 메모리와 CPU 간의 속도 차이를 완화하기 위해 메모리에서 "앞으로 사용할 것으로 예상되는 데이터를 미리 가져와" 임시 저장 해두는 장소

       - 예상 방법 : 지역성 -> 시간 지역성과 공간 지역성

       - CPU는 메모리르 접근 해야할 때 = 가까운 캐시를 우선 방문

   📍 메모리 종류

       - 휘발성(RAM) vs 비휘발성 (Disk)
       - RAM = Random Access Memory : 주소에 의한 임의 접근
       - Read Only Memory

# 컴퓨터 시스템 / 프로그램 작동 원리 

## 1. CPU의 구성 요소 

- 산술논리 연산장치(산술 계산, ALU) > +,-,*,/ 과 같은 산술 연산과 AND, OR 같은 논리 연산을 수행 
- 제어장치 > ALU가 뭘 연산해야 하는지 해석해준다. CPU에서 명령어에 따른 작업을 제시 
- 레지스터 > CPU 내에 데이터를 임시로 보관. 실제 연산/작업은 모두 레지스터를 거쳐서 수행된다

  📍 Register = 찐 CPU가 처리하는 메모리

       사용자 가시 레지스터
  
          1. 데이터 레지스터 : 일반 데이터를 임시로 저장하는 범용 레지스터
          2. 주소 레지스터 : 데이터 또는 명령어가 저장된 메모리의 주소를 저장한다

       사용자 불가시 레지스터

          1. 프로그램 카운터 : 다음에도 실행할 명령어의 위치 정보를 저장
          2. 명령어 레지스터 : 현재 실행 중인 명령어를 저장
          3. 메모리 주소 레지스터 : 메모리 관리자가 접근해야 할 메모리의 주소를 저장
          4. 메모리 버퍼 레지스터 : 메모리 관리자가 메모이레서 가져온 데이터를 임시로 저장
          5. 프로그램 상태 레지스터 : 연산 결과를 저장 
      

⭐️ BP, SP = Base Pointer(Stack 바닥) / Stack Pointer (Stack 꼭대기)
⭐️ IP = Instruction Pointer (다음에 읽어드릴 번지(?)를 나타내줌) 



## 2. 메모리 보호 기법 

> Segmentation
> 
> 부팅 : 컴퓨터를 켰을 때 OS에 메모리를 올리는 과정 (안 쓰는 경우 디스크에 저장)

        - 부트로더 : Boot Strap (Disk에 저장되어 있는 특별한 기능을 하는 것을 가지고 온다) 

        - HW 점검 후 미리 '약속된' 저장장치의 '약속됭' 위치의 프로그램을 실행시킨다. 
            = Master Boot Record(MBR) : 디스크 첫번째 섹터 

### ✔️ CPU가 어떤 작업을 수행하던 도중 외부에서 들어오는 작업 요청을 처리하는 방법 

    1. Polling : CPU가 입력을 가지러 간다 

    📍 polling 

        - CPU가 직업 입출력장치에서 데이터를 가져오거나 내보내는 방식
        - CPU가 외부 상태를 주기적으로 검사하여 요청이 있으면 처리 
            ⭐️ 메시지는 CPU가 poll을 할때 까지 기다려야함 
            
    📍 polling 주기 : 높을 수록 메세지 응답속도 향상 <--> 낮을수록 실시간성 저하 
    
        - CPU 작업 처리 속도에 영향 
-----------
    2. Interrupt : CPU에 입력을 넣어준다

        📍 interrupt : CPU의 활용율을 높일 수 있다. 

            - 각 자원들이 능동적으로 자신의 상태변화를 CPU에게 알리는 방식 
              (CPU는 필요할 때만 외부 장치와 통신하고 남는 시간동안 다른 작업 처리)
            - 외부장치가 CPU를 사용해야 할 때 => IRQ(Interrupt ReQuest) 전송
            - 인터럽트 동시 발생 (Interrput vector, Nested interrupt)

        📍 확인

            - cat /proc/interrupts
            - misnfo32.exe

        📍 인터럽트 종류 
        
            - HW interrupt : CPU 외부의 디스크 컨트롤러나 주변장치로부터 요구 
            - SW interrupt : CPU 내부에서 자신이 실행한 명령어나 CPU의 명령 실행에 관련된 모듈 변화 (trap, 예외라고 부른다) 

### ✔️ DMA (Direct Memory Access) : CPU 개입 없이 메모리와 하드웨어 장치 간 데이터 전송 

동작모드

- 사이클 스틸링 모드 = 경쟁적  : 한번의 DMA 동작 중 한 word 정도의 데이터를 전송시 적용 
  - 버스에게 우선순위 줘서 빠르게 입출력이 가능하게 함

- 버스트 모드 = 배타적 : 한번의 DMA 동작 중 Block 단위의 데이터 전송시 적용 
    - 고속 입출력 장치 대상, 데이터 전송이 완료될 때까지 버스 사이클 독점       
- Demand Transfer Mode : 요구한만큼 전송하기 
    - DMA가 CPU에게 요구한 카운트 만큼 버스의 제어권을 가짐
    - 카운트가 끝나거나, 중간에 제어권을 반환하면 다시 CPU가 제어권을 가져감 


### 병렬 처리 : 동시에 여러 개의 명령어를 처리하여 작업의 능률을 올리는 방식 

| 동시성(Concurrent) |  병렬성(Parallel) |
| :- |  :- |
| 동시에 실행되는 것 같이 보이는 것 | 실제로 동시에 여러 작업이 처리되는 것 |
| 싱글 코어에서 멀티 쓰레드를 동작 시키는 방법 | 멀티 코어에서 멀티 쓰레드를 동작시키는 방식 |
| 한번에 많은 것을 처리 | 한번에 많은 일을 처리 |
| 논리적인 개념 | 물리적인 개념|
        


![KakaoTalk_Photo_2024-04-08-19-48-17](https://github.com/subinsong01/TIL/assets/134045937/5fc57e47-09bc-460d-8e6f-a366df71a735)


### 파이프라이닝 : 명령어를 여러 개의 단계로 분할한 후 각 단계를 동시에 처리 

1) 명령어 패치(IF) : 다음에 실행할 명령어를 명령어 레지스터에 저장
2) 명령어 해석(ID) : 명령어 해석
3) 실행(EX) : 해석한 결과를 토대로 실행
4) 쓰기 (WB) : 실행된 결과를 메모리에 저장

   📍 파이프라인

       1. 명령어를 겹쳐서 실행하는 방법으로 하나의 코어에 여러 개의 스레드를 실행하는 방식
   
       2. 명령어를 여러 개의 단계로 분할한 후 각 단계를 동시에 처리하는 하드웨어를 독립적으로 구성

    📍 (파이프라이닝) 병렬 처리 시 고려 사항

       1. 상호 의존성이 없어야함
   
       2. 각 단계별 처리 시간이 일정 해야함
       - 오랜 시간이 걸려서 전체 작업시간이 증가 (병목 현상) ==> 놀고있는 stage가 생김(파이프라인 버블)

       3. 전체 작업 시간을 몇 단계로 나눌지 잘 따져야 함

### Pipeline hazard(1)

1) 실제로 처리 시간이 일정하지 않고, 처리 단계가 균등하지 않음
   

| 헤저드(hazard) |  발생 이유 |
| :- |  :- |
| 구조적 | 자원 충돌로 여러 명령의 동시 수행 시 발생 |
| 제어| 순차적 명령어가 분기에 의해 버려지는 경우 |
| 데이터 | 미수행된 명령의 결과값 참조 시도 발생 |

    📍 구조 헤저드
    
    > 프로세스의 자원이 부족할 때 : 서로 다른 명령어가 같은 자원에 접근하려 할 때 발생 
    > 해결방안 : 추가 자원 확보 

    📍 제어 헤저드 

    > 의존성 때문에 발생 
    > 분기에 의해서 제어 순서가 바뀌어 파이프라인 내 명령어들이 쓸모 없어짐 
    > 해결방안 : 대기, 예측, 우선 실행 

    📍 데이터 헤저드

    > 이전 명령어의 결과를 기반으로 다음 명령이 수행될 때 발생 
    
   
