# 운영체제 개요
### 1. 운영체제가 하는 일
- 효율
- 안정적
- 확장
- 편리

1-1. 종류
> P2P(Peer to Peer)
  - 특정 서버에 집중되는 과부화를 해결하기 위해 만든 시스템
  - 서버를 거치지 않고 사용자와 사용자를 직접 연결

> 가상화 시스템
> 
> 모바일 운영체제
> 
> 임베디드 운영체제
> 
> 실시간 운영체제 : 정해진 데드라인 시간 이내에 처리되도록 보장 하는 것을 목표

### 2. 운영체제 구조
> 운영체제 구조는 크게 2(+1) 구조로 볼 수 있다.
> 
✔️ 커널
   - 운영체제의 핵심
   - 핵심적인 기능을 모아둠
   - 응용 sw들은 커널에 요청함으로서 hw 자원들을 이용하게 됨
   - 커널이 하는 일 == 운영체제가 하는 일 (*매우 중요*)
   - 외부로부터 직접 노출이 안되는 것이 (당연히) 좋음
   - User-mode <-> Kernel-mode 의 분리 됨
     
      📍 System Call : 커널이 자신의 기능을 함수 형태로 제공해주는 것
       - 커널이 입력값의 검증, 권한의 확인, 작업 순서 제어 등 -> 커널의 보호
       - API를 통해 만들어진 프로그램들은 최종적으로 이 시스템콜을 호출하는 형태가 됨
    
       - syscall별 소요시간을 출력해줌 (**strace -T option**)
    
      📍 커널의 시간
       - 아무것도 하지 않는 프로그램 vs syscall을 적극적으로 호출하는 프로그램
       - syscall의 경우 sys 시간이 생긴다
         
         🖍️ real : 총 프로그램 실행 시간
         
         🖍️ user : user-level 실행 시간
         
         🖍️ sys : kernel-level 실행 시간

        📍 커널은 어떻게 설계하는지에 따라 조금씩 모양이 다름
     
           1. 단일형 커널
             - 초창기 구조
             - 커널의 모든 기능이 한 덩어리로
     
           2. 계층형 커널
             - 비슷한 기능을 가진 모듈별로 계층을 만듬(Kernel stack)
             - 대부분 이 구조
     
           3. 마이크로 커널(협업에서 좋지 않음)
             - 커널은 아주 기본적인 기능만 제공
             - 대부분의 기능은 User-level로 이식하고 프로세스간 통신으로 시스템 운영 
     
✔️ 인터페이스
   - 커널에 명령을 전달하고 실행 결과를 알려주는 역할
   - 시스템콜이 호출되는 방식
     - OS가 제공하는 라이브러리 또는 API
     - 대부분의 xNIC app들은 libc를 링킹해서 사용
     - 확인 : ldd 명령어
     - syscall의 Assembly code 확인 : objdump
       
       📍 -M intel : Intel syntax 출력
       
       📍 --disassembl = __write : write 함수만 출력

     - 시스템콜은 일반 함수와 다르게 언어에서 직접 호출이 불가능 하다 : CPU에 의해 호출

### 3. 디바이스 드라이버 : 커널이랑 하드웨어랑 연결하는 것을 의미 (커널과 하드웨어 그 중간 어딘가에 위치)
  > HW와 직접 연결되고 입력 신호에 대한 '약속'을 정하는 것 

### 4. 가상머신 
  -  운영체제가 다르면 프로그램별 호환이 안됨
  -  운영체제와 응용 프로그램 사이에서 작동, 운영체제간 이식성을 높여줌 = 하나의 프로그램에 다양한 환경을 제공  
  -  일종의 API 호환 레이어 (통역가/번역가)
  -  응용 프로그램이 API 모두 동일한 환경에서 작동하는 것처럼 보여짐
